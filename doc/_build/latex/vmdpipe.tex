% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


\title{vmdpipe Documentation}
\date{Sep 02, 2016}
\release{1}
\author{Salvatore M Cosseddu}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Description:}
\label{index:description}\label{index:welcome-to-vmdpipe-s-documentation}
VMDpipe provides a set of api to use vmd from python executing tcl code and scripts.


\chapter{Notes:}
\label{index:notes}
In the present version, the module does not provide any class,
python interpreter in VMD is not supported and only a single VMD
instance is allowed.

VMD executable can be set using vmdpipe.Vsetpath(path) and retrieved using vmdpipe.Vgetpath(path)

vmdpipe.printout (boolean) = True is useful for interactive: vmd stdout is
printed to screen instead of being returned as strings

defaultTimeout specifies the wait time (in seconds) before an error is raised
if VMD does not respond. In this case VMD instance is not closed.
You can wait further using vmdpipe.ping() or kill the instance with vmdpipe.Vkill()

ioLag defines a default time interval for reading vmd stdout after sending a command
using vmdpipe.send\_string()

Module is implemented using subprocess module and vmd stderr is accessible via vmdpipe.\_vmdin.stderr
(See subprocess manual)

Contents:


\section{vmdpipe package}
\label{vmdpipe::doc}\label{vmdpipe:vmdpipe-package}

\subsection{vmdpipe module}
\label{vmdpipe:module-vmdpipe}\label{vmdpipe:vmdpipe-module}\index{vmdpipe (module)}
VMDpipe provides a set of api to use vmd from python executing tcl code and scripts.

In the present version, the module does not provide any class,
python interpreter in VMD is not supported and only a single VMD
instance is allowed.

VMD executable can be set using vmdpipe.Vsetpath(path) and retrieved using vmdpipe.Vgetpath(path)

vmdpipe.printout (boolean) = True is useful for interactive: vmd stdout is
printed to screen instead of being returned as strings

defaultTimeout specifies the wait time (in seconds) before an error is raised 
if VMD does not respond. In this case VMD instance is not closed. 
You can wait further using vmdpipe.ping() or kill the instance with vmdpipe.Vkill()

ioLag defines a default time interval before reading vmd stdout after sending a command 
using vmdpipe.send\_string()

Module is implemented using subprocess module and vmd stderr is accessible via vmdpipe.\_vmdin.stderr 
(See subprocess manual)
\index{Vclose() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.Vclose}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{Vclose}}{\emph{timeout=10}}{}
close the vmd instance opened by Vopen() and return the returncode

\end{fulllineitems}

\index{Vgetpath() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.Vgetpath}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{Vgetpath}}{}{}
get path of vmd used by the module

\end{fulllineitems}

\index{Vkill() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.Vkill}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{Vkill}}{}{}
kill the vmd instance opened by Vopen()

\end{fulllineitems}

\index{Vopen() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.Vopen}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{Vopen}}{\emph{gui=True}, \emph{timeout=15}, \emph{returnInitStdout=False}}{}
open a vmd instance, use only for interactive/test purposes
set text to False for interactive use with gui

An error is raised if VMD does not respond within timeout sectonds. In this case VMD instance is not closed. 
You can wait further, observe using ping() or kill the instance with Vkill()

if returnInitStdout is True, the function return the init stdout of VMD as string

if vmd.printout is True, init stdout is printed to screen (useful for interactive use)

\end{fulllineitems}

\index{Vsetpath() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.Vsetpath}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{Vsetpath}}{\emph{p}}{}
set path of vmd, default vmd from bash env

\end{fulllineitems}

\index{aspylist() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.aspylist}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{aspylist}}{\emph{x}}{}
convert tcl list in python list

\end{fulllineitems}

\index{astcllist() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.astcllist}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{astcllist}}{\emph{x}}{}
convert python list in tcl list

\end{fulllineitems}

\index{callback() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.callback}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{callback}}{\emph{signal}, \emph{capture\_stdout}}{}
listen vmd for a signal and capture stdout

\end{fulllineitems}

\index{isVMDopen() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.isVMDopen}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{isVMDopen}}{}{}
\end{fulllineitems}

\index{ping() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.ping}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{ping}}{\emph{timeout=15}, \emph{signal='vmdpipesignal'}}{}
Send signal to vmd and wait timeout seconds for the response. Finally return the stdout

\end{fulllineitems}

\index{runAndReturn() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.runAndReturn}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{runAndReturn}}{\emph{script}, \emph{addexit=True}}{}
Execute a vmd script in a independent vmd instance, close and return the stdout. 
Both file paths and strings as accepted as script. If script is a string, ``exit 0'' statement
is added at the end. This should be generally fine but if, for any reason, you want to
change this default behavior, use addexit=False.

\end{fulllineitems}

\index{send\_string() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.send_string}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{send\_string}}{\emph{commandString}, \emph{timeout=15}, \emph{returnAll=False}, \emph{latency=0.01}}{}
send tcl code to vmd instance created with Vopen()
- timeout : an error is raised if VMD does not respond within timeout seconds. VMD process is not killed.
\begin{quote}

You further observe the process using ping() or kill it using Vkill(). Increase timeout for commands that take long time.
\end{quote}
\begin{itemize}
\item {} 
if returnAll=False (default), function tries to return only the final return value from the tcl interpreter;
if returnAll=True, function returns all the tcl stdout from the command as string

\item {} 
Increase latency if

\end{itemize}

if vmdpipe.printout is true vmd stdout is not retured but printed on screen, 
useful for interactive use.

\end{fulllineitems}

\index{source() (in module vmdpipe)}

\begin{fulllineitems}
\phantomsection\label{vmdpipe:vmdpipe.source}\pysiglinewithargsret{\code{vmdpipe.}\bfcode{source}}{\emph{filename}, \emph{**kwargs}}{}
source a file in the vmd instance created with Vopen()

\end{fulllineitems}



\section{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}
Vmdpipe provides useful functions to use VMD either iteractively or in a python script. Few example of it usage are here listed.


\subsection{Interactive mode:}
\label{tutorial:interactive-mode}
Open an interactive session with GUI:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{vmdpipe} \PYG{k}{as} \PYG{n+nn}{vmd}
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{Vopen}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

that correspond to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{vmdpipe} \PYG{k}{as} \PYG{n+nn}{vmd}
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{printout}\PYG{o}{=}\PYG{k+kc}{True}       \PYG{c+c1}{\PYGZsh{} default, VMD output will be printed on screen}
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{Vopen}\PYG{p}{(}\PYG{n}{text}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} default, open vmd}
\end{Verbatim}

Now you can send some command: vmdpipe will try to capture the return value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{molID}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mol pdbload 1k4c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} load a molecule and store molID}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mol }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ loaded}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{molID}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

By default vmdpipe wait 15s before raising an error:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{molID}\PYG{o}{=}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sleep 20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} an error is raised}
\end{Verbatim}

Vmd is not killed, but output to that point is lost. This is made to prevent issues to underlying vmd process to block your script or workflow.
You can check if VMD is still alive, send a signal to check if it is responsive, or kill it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{isVMDopen}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m still alive!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{vmd}\PYG{o}{.}\PYG{n}{ping}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{vmd}\PYG{o}{.}\PYG{n}{Vkill}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If you know your command will take longer than 15s, increase the timeout (in seconds):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set t test; sleep 20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} now it is ok!}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

As you can see, no return value was captured. Because, by default, send\_string will capture return
value of the very last command. If you prefere otherwise, you can save all the stdout printed
as a result of your command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{set t test}
\PYG{l+s+s2}{set g }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{2 3\PYGZcb{}}
\PYG{l+s+s2}{set h [list \PYGZdl{}t \PYGZdl{}g]}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{,} \PYG{n}{returnAll}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} now everything is stored}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}
\begin{description}
\item[{As seen, send\_string() accepts very complex list of commands. Simpler way to do so is using::}] \leavevmode
``''''...''``''

\end{description}

Alternatively you can store your commands in a file, and source them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{source}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.tcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

source() accepts same options of send\_string().

Vmdpipe provides a function to convert tcl lists in python lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tcl \PYGZhy{}\PYGZhy{}\PYGZgt{} python}
\PYG{n}{t}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{aspylist}\PYG{p}{(}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{set h [list [list 2 3] [list 4 5] [list 6 7]]))}
\end{Verbatim}

and back:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} python \PYGZhy{}\PYGZhy{}\PYGZgt{} tcl}
\PYG{n}{t}\PYG{o}{=}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{aspylist}\PYG{p}{(}\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{send\PYGZus{}string}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{set h [list [list 2 3] [list 4 5] [list 6 7]]))}
\end{Verbatim}

To close the vmd instance use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{Vclose}\PYG{p}{(}\PYG{p}{)}                                 \PYG{c+c1}{\PYGZsh{} close vmd}
\end{Verbatim}


\subsection{Text mode:}
\label{tutorial:text-mode}
Text mode is useful for scripting purposes. In a script, it is safest to
run the script opening and closing each time a vmd instance. This is done
using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{runAndReturn}\PYG{p}{(}\PYG{n}{script}\PYG{p}{)}
\end{Verbatim}

However, many times you want to maintain the vmd instance opened and
communicate with it. In these cases you can open the session with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{vmdpipe} \PYG{k}{as} \PYG{n+nn}{vmd}
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{printout}\PYG{o}{=}\PYG{k+kc}{False}               \PYG{c+c1}{\PYGZsh{} nothing will be printed to screen}
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{Vopen}\PYG{p}{(}\PYG{n}{text}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{} open vmd in text mode}
\end{Verbatim}

and use all functions above described. It is important to have proper
communications with the underlying vmd instance. Option ``latency''
in vmdpipe.send\_string() set time interval before reading vmd stdout after
sending a command. It can be changed globally by setting:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vmd}\PYG{o}{.}\PYG{n}{ioLag}\PYG{o}{=}\PYG{l+m+mf}{0.001}
\end{Verbatim}

Default (0.01) should be fine in most cases, however you can play a
bit reducing it to improve performance or increasing it if you notice vmd
hanging.


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{v}
\item {\texttt{vmdpipe}}, \pageref{vmdpipe:module-vmdpipe}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
